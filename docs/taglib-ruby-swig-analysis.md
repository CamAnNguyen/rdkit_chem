# taglib-ruby: SWIG Binding Generation Analysis

This document analyzes how the [taglib-ruby](https://github.com/robinst/taglib-ruby) project generates Ruby bindings for the TagLib C++ library using SWIG.

## Table of Contents

- [Overview](#overview)
- [Platform Support](#platform-support)
- [Project Architecture](#project-architecture)
- [SWIG Interface Files](#swig-interface-files)
- [Type Mapping System](#type-mapping-system)
- [Memory Management](#memory-management)
- [Polymorphic Object Handling](#polymorphic-object-handling)
- [Extending C++ Classes](#extending-c-classes)
- [Build Process](#build-process)
- [Pure Ruby Additions](#pure-ruby-additions)
- [Summary Diagram](#summary-diagram)
- [Key Takeaways](#key-takeaways)

---

## Overview

**taglib-ruby** wraps the full TagLib C++ API (not just the minimal C API) using SWIG, enabling Ruby developers to read/write audio metadata for formats including:

- MP3 (ID3v1, ID3v2)
- Ogg Vorbis
- FLAC
- MP4/M4A
- WAV
- AIFF

---

## Platform Support

### Supported Platforms

| Platform | Support Status | Notes |
|----------|----------------|-------|
| **Linux** | Full Support | Debian/Ubuntu: `sudo apt-get install libtag1-dev` |
| **macOS** | Full Support | Via Homebrew or MacPorts (see below) |
| **Windows** | Full Support | Pre-compiled DLL bundled in binary gem |
| **FreeBSD** | Should work | Requires TagLib installation |

### macOS Installation

macOS is fully supported. Installation methods:

#### Via Homebrew (Recommended)

```bash
# Install TagLib
brew install taglib

# Get the installation path
brew info taglib
# Output: /opt/homebrew/Cellar/taglib/1.13 (122 files, 1.6MB) *

# Install gem with path
TAGLIB_DIR=/opt/homebrew/Cellar/taglib/1.13 gem install taglib-ruby
```

#### Via MacPorts

```bash
sudo port install taglib
gem install taglib-ruby
```

#### Troubleshooting macOS

If `clang++` has issues with a specific TagLib version, use a different compiler:

```bash
TAGLIB_RUBY_CXX=g++-4.2 gem install taglib-ruby
```

For Bundler:

```bash
TAGLIB_DIR=/opt/homebrew/Cellar/taglib/1.13 bundle install
```

### Version Compatibility

| TagLib Version | taglib-ruby Version |
|----------------|---------------------|
| 1.11.1 - 1.x   | `gem install taglib-ruby --version '< 2'` |
| 2.0.1+         | `gem install taglib-ruby --version '>= 2'` |

---

## Project Architecture

```
taglib-ruby/
├── ext/                          # C++ extension source files
│   ├── extconf_common.rb         # Shared build configuration
│   ├── taglib_base/              # Base module (core types)
│   │   ├── taglib_base.i         # SWIG interface file
│   │   ├── includes.i            # Shared type conversions
│   │   ├── taglib_base_wrap.cxx  # GENERATED by SWIG
│   │   └── extconf.rb            # Ruby extension config
│   ├── taglib_mpeg/              # MPEG module
│   ├── taglib_id3v2/             # ID3v2 module
│   ├── taglib_mp4/               # MP4 module
│   └── ... (other formats)
├── lib/                          # Pure Ruby wrappers
│   ├── taglib.rb                 # Main entry point
│   └── taglib/
│       ├── base.rb               # Ruby additions to base module
│       └── mpeg.rb               # Ruby additions to MPEG module
└── tasks/
    └── swig.rake                 # SWIG generation tasks
```

---

## SWIG Interface Files

SWIG interface files (`.i`) are the core of binding generation. SWIG reads these and produces C++ wrapper code (`_wrap.cxx`).

### Module Declaration

```cpp
%module "TagLib"    // Creates Ruby module TagLib
%{
// C++ headers to include in generated wrapper
#include <taglib/taglib.h>
#include <taglib/tbytevector.h>
#include <taglib/fileref.h>
#include <taglib/tag.h>
%}

%include "includes.i"   // Shared type definitions
```

### Key SWIG Directives

| Directive | Purpose |
|-----------|---------|
| `%module` | Defines the Ruby module name |
| `%{ ... %}` | Raw C++ code inserted into wrapper |
| `%include` | Include another SWIG interface or C++ header |
| `%import` | Import types from another module (no wrapper generation) |
| `%rename` | Rename methods/classes |
| `%ignore` | Exclude methods/classes from wrapping |
| `%extend` | Add methods to wrapped classes |
| `%typemap` | Define type conversions |
| `%freefunc` | Custom destructor function |
| `%apply` | Apply typemap to additional types |

### Method Renaming for Ruby Conventions

SWIG regex-based renaming converts C++ naming to Ruby idioms:

```cpp
// setFoo() -> foo=
%rename("%(regex:/set([A-Z][a-z]*)/\\L\\1=/)s",
        regexmatch$name="^set([A-Z][a-z]*)$") "";

// isFoo() -> foo?
%rename("%(regex:/is([A-Z][a-z]*)/\\L\\1?/)s",
        regexmatch$name="^is([A-Z][a-z]*)$") "";
```

**Result:**
- `setTitle(string)` -> `title=(string)`
- `isValid()` -> `valid?`

### Hiding Unwanted API

```cpp
// Ignore deprecated methods
%ignore TagLib::MPEG::length;  
%ignore TagLib::AudioProperties::length;

// Ignore internal-only methods
%ignore TagLib::ID3v2::Tag::render;
%ignore TagLib::List::operator[];

// Ignore IOStream constructors (not useful from Ruby)
%ignore TagLib::FileRef::FileRef(IOStream*, bool, AudioProperties::ReadStyle);
```

---

## Type Mapping System

The typemap system converts between C++ and Ruby types. This is the most sophisticated part of the bindings.

### String Conversion Functions

```cpp
// C++ TagLib::String -> Ruby String
VALUE taglib_string_to_ruby_string(const TagLib::String & string) {
  VALUE result = rb_str_new2(string.toCString(true));  // UTF-8
  ASSOCIATE_UTF8_ENCODING(result);
  return result;
}

// Ruby String -> C++ TagLib::String
TagLib::String ruby_string_to_taglib_string(VALUE s) {
  if (NIL_P(s)) {
    return TagLib::String();
  } else {
    return TagLib::String(
      RSTRING_PTR(CONVERT_TO_UTF8(StringValue(s))), 
      TagLib::String::UTF8
    );
  }
}
```

### Applying Typemaps

```cpp
// Output: C++ function returns TagLib::String
%typemap(out) TagLib::String {
  $result = taglib_string_to_ruby_string($1);
}

// Input: C++ function takes TagLib::String parameter
%typemap(in) TagLib::String (TagLib::String tmp) {
  tmp = ruby_string_to_taglib_string($input);
  $1 = &tmp;
}

// Apply to references too
%apply TagLib::String { TagLib::String &, const TagLib::String & };
```

**Typemap Variables:**
- `$1` - The C++ variable (input or result)
- `$input` - The Ruby VALUE input
- `$result` - The Ruby VALUE to return

### Container Type Conversions

```cpp
// C++ StringList -> Ruby Array
VALUE taglib_string_list_to_ruby_array(const TagLib::StringList & list) {
  VALUE ary = rb_ary_new2(list.size());
  for (auto it = list.begin(); it != list.end(); it++) {
    VALUE s = taglib_string_to_ruby_string(*it);
    rb_ary_push(ary, s);
  }
  return ary;
}

// Ruby Array -> C++ StringList
TagLib::StringList ruby_array_to_taglib_string_list(VALUE ary) {
  TagLib::StringList result;
  if (NIL_P(ary)) return result;
  for (long i = 0; i < RARRAY_LEN(ary); i++) {
    VALUE e = rb_ary_entry(ary, i);
    result.append(ruby_string_to_taglib_string(e));
  }
  return result;
}
```

### ByteVector Conversion (Binary Data)

```cpp
VALUE taglib_bytevector_to_ruby_string(const TagLib::ByteVector &byteVector) {
  return rb_str_new(byteVector.data(), byteVector.size());
}

TagLib::ByteVector ruby_string_to_taglib_bytevector(VALUE s) {
  if (NIL_P(s)) {
    return TagLib::ByteVector();
  } else {
    return TagLib::ByteVector(RSTRING_PTR(StringValue(s)), RSTRING_LEN(s));
  }
}
```

---

## Memory Management

Managing memory between Ruby's GC and C++ ownership is critical.

### Object Tracking

```cpp
%trackobjects;  // Enable SWIG object tracking
```

### Custom Destructor (`%freefunc`)

When a file object is destroyed, child objects must be unlinked from Ruby:

```cpp
%freefunc TagLib::MPEG::File "free_taglib_mpeg_file";

%header %{
static void free_taglib_mpeg_file(void *ptr) {
    TagLib::MPEG::File *file = (TagLib::MPEG::File *) ptr;

    // Unlink tag before deletion
    TagLib::Tag *tag = file->tag();
    if (tag) {
      SWIG_RubyUnlinkObjects(tag);
      SWIG_RubyRemoveTracking(tag);
    }

    // Unlink ID3v2 frames
    TagLib::ID3v2::Tag *id3v2tag = file->ID3v2Tag(false);
    if (id3v2tag) {
      TagLib::ID3v2::FrameList frames = id3v2tag->frameList();
      for (auto it = frames.begin(); it != frames.end(); it++) {
        SWIG_RubyUnlinkObjects(*it);
        SWIG_RubyRemoveTracking(*it);
      }
      SWIG_RubyUnlinkObjects(id3v2tag);
      SWIG_RubyRemoveTracking(id3v2tag);
    }

    // Unlink properties
    TagLib::MPEG::Properties *properties = file->audioProperties();
    if (properties) {
      SWIG_RubyUnlinkObjects(properties);
      SWIG_RubyRemoveTracking(properties);
    }

    SWIG_RubyUnlinkObjects(ptr);
    SWIG_RubyRemoveTracking(ptr);

    delete file;
  }
%}
```

### Ownership Transfer (`DISOWN`)

When passing objects to C++ that takes ownership:

```cpp
// Frame is "disowned" when added to tag
%apply SWIGTYPE *DISOWN { TagLib::ID3v2::Frame *frame };

// Custom disown typemap
%typemap(in, noblock=1) SWIGTYPE *DISOWN (int res = 0) {
  res = SWIG_ConvertPtr($input, %as_voidptrptr(&$1), $descriptor, 
                        SWIG_POINTER_DISOWN | %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type", $symname, $argnum);
  }
  SWIG_RubyUnlinkObjects($1);
  SWIG_RubyRemoveTracking($1);
}
```

---

## Polymorphic Object Handling

The ID3v2 module returns different frame types based on frame ID:

```cpp
VALUE taglib_id3v2_frame_to_ruby_object(const TagLib::ID3v2::Frame *frame) {
  TagLib::ByteVector id = frame->frameID();
  void *f = SWIG_as_voidptr(frame);
  swig_type_info *ti;
  
  // Dynamic type detection
  if (dynamic_cast<const TagLib::ID3v2::UnknownFrame *>(frame))
    ti = SWIGTYPE_p_TagLib__ID3v2__UnknownFrame;
  else if (id == "APIC")
    ti = SWIGTYPE_p_TagLib__ID3v2__AttachedPictureFrame;
  else if (id == "COMM")
    ti = SWIGTYPE_p_TagLib__ID3v2__CommentsFrame;
  else if (id == "GEOB")
    ti = SWIGTYPE_p_TagLib__ID3v2__GeneralEncapsulatedObjectFrame;
  else if (id == "TXXX")
    ti = SWIGTYPE_p_TagLib__ID3v2__UserTextIdentificationFrame;
  else if (id.startsWith("T"))
    ti = SWIGTYPE_p_TagLib__ID3v2__TextIdentificationFrame;
  else if (id.startsWith("W"))
    ti = SWIGTYPE_p_TagLib__ID3v2__UrlLinkFrame;
  else
    ti = SWIGTYPE_p_TagLib__ID3v2__Frame;
    
  return SWIG_NewPointerObj(f, ti, 0);
}
```

---

## Extending C++ Classes

SWIG `%extend` adds methods not in the original C++ class:

### Adding close() Method

```cpp
%extend TagLib::MPEG::File {
  void close() {
    free_taglib_mpeg_file($self);
  }
}
```

### Factory Methods for Overloaded Constructors

```cpp
%extend TagLib::MP4::Item {
  static TagLib::MP4::Item * from_bool(bool q) {
    return new TagLib::MP4::Item(q);
  }
  static TagLib::MP4::Item * from_int(int n) {
    return new TagLib::MP4::Item(n);
  }
  static TagLib::MP4::Item * from_string_list(const TagLib::StringList &list) {
    return new TagLib::MP4::Item(list);
  }
  static TagLib::MP4::Item * from_cover_art_list(const TagLib::MP4::CoverArtList &list) {
    return new TagLib::MP4::Item(list);
  }
}
```

### Adding Ruby Hash Methods

```cpp
namespace TagLib {
  %extend Map<String, MP4::Item> {
    VALUE to_a() {
      VALUE ary = rb_ary_new2($self->size());
      for (auto it = $self->begin(); it != $self->end(); it++) {
        VALUE pair = rb_ary_new2(2);
        rb_ary_push(pair, taglib_string_to_ruby_string(it->first));
        rb_ary_push(pair, SWIG_NewPointerObj(&(it->second), 
                    SWIGTYPE_p_TagLib__MP4__Item, 0));
        rb_ary_push(ary, pair);
      }
      return ary;
    }

    VALUE to_h() {
      VALUE hsh = rb_hash_new();
      for (auto it = $self->begin(); it != $self->end(); it++) {
        rb_hash_aset(hsh,
          taglib_string_to_ruby_string(it->first),
          SWIG_NewPointerObj(&(it->second), SWIGTYPE_p_TagLib__MP4__Item, 0));
      }
      return hsh;
    }
  }
}
```

---

## Build Process

### SWIG Generation (`rake swig`)

```ruby
# tasks/swig.rake
def run_swig(mod)
  swig = `which swig`.chomp
  include_args = "-I#{ENV['TAGLIB_DIR']}/include"
  
  Dir.chdir("ext/#{mod}") do
    sh "#{swig} -c++ -ruby -autorename -initname #{mod} #{include_args} #{mod}.i"
  end
end

# File dependencies
file 'ext/taglib_base/taglib_base_wrap.cxx' => 
     ['ext/taglib_base/taglib_base.i', 'ext/taglib_base/includes.i'] do
  run_swig('taglib_base')
end

file 'ext/taglib_mpeg/taglib_mpeg_wrap.cxx' => 
     ['ext/taglib_mpeg/taglib_mpeg.i'] + base_dependencies do
  run_swig('taglib_mpeg')
end
```

**SWIG Command Flags:**
- `-c++` - Input is C++
- `-ruby` - Generate Ruby bindings
- `-autorename` - Auto-convert naming conventions
- `-initname` - Set Ruby extension init function name

### Extension Configuration (`extconf.rb`)

```ruby
# ext/extconf_common.rb
require 'mkmf'

taglib_dir = ENV['TAGLIB_DIR']
dir_config('tag', taglib_dir)  # Find TagLib headers/libs

have_library('stdc++')
have_library('tag')

$CFLAGS << ' -DSWIG_TYPE_TABLE=taglib'
$CXXFLAGS << ' -std=c++17'  # TagLib 2.0 requires C++17

# Allow custom compiler
RbConfig::MAKEFILE_CONFIG['CXX'] = ENV['TAGLIB_RUBY_CXX'] if ENV['TAGLIB_RUBY_CXX']
```

### Rake Extension Tasks

```ruby
# tasks/ext.rake
require 'rake/extensiontask'

Rake::ExtensionTask.new('taglib_base', $gemspec) do |ext|
  ext.cross_compile = true
  ext.cross_platform = Build.plat
end

Rake::ExtensionTask.new('taglib_mpeg', $gemspec) do |ext|
  ext.cross_compile = true
  ext.cross_platform = Build.plat
end
# ... more extensions
```

---

## Pure Ruby Additions

After SWIG generates the C extension, Ruby code adds conveniences:

### Block Syntax for File Operations

```ruby
# lib/taglib/base.rb
module TagLib
  module FileOpenable
    def open(*args)
      file = new(*args)
      begin
        result = yield file
      ensure
        file.close  # Ensures proper cleanup
      end
      result
    end
  end

  class FileRef
    extend FileOpenable
  end
end

# lib/taglib/mpeg.rb
module TagLib::MPEG
  class File
    extend ::TagLib::FileOpenable
  end
end
```

**Usage:**

```ruby
# Automatically closes file after block
TagLib::MPEG::File.open('song.mp3') do |file|
  puts file.tag.title
  file.tag.title = "New Title"
  file.save
end
```

---

## Summary Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                     SWIG Interface Files (.i)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
│  │ taglib_base │  │ taglib_mpeg │  │ taglib_mp4  │  ...         │
│  │    .i       │  │    .i       │  │    .i       │              │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘              │
└─────────┼────────────────┼────────────────┼──────────────────────┘
          │                │                │
          ▼                ▼                ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                    SWIG (swig -c++ -ruby)                    │
    └─────────────────────────────────────────────────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Generated Wrapper (.cxx)                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
│  │ taglib_base │  │ taglib_mpeg │  │ taglib_mp4  │              │
│  │ _wrap.cxx   │  │ _wrap.cxx   │  │ _wrap.cxx   │              │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘              │
└─────────┼────────────────┼────────────────┼──────────────────────┘
          │                │                │
          ▼                ▼                ▼
    ┌─────────────────────────────────────────────────────────────┐
    │          C++ Compiler (g++ / clang++)                        │
    │                Links against libtag                          │
    └─────────────────────────────────────────────────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────┐
│                  Native Extensions (.so / .bundle)               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
│  │ taglib_base │  │ taglib_mpeg │  │ taglib_mp4  │              │
│  │    .so      │  │    .so      │  │    .so      │              │
└─────────────────────────────────────────────────────────────────┘
          │                │                │
          ▼                ▼                ▼
    ┌─────────────────────────────────────────────────────────────┐
    │              Pure Ruby Wrappers (lib/taglib/*.rb)            │
    │              - Adds open() block syntax                      │
    │              - Ruby convenience methods                      │
    └─────────────────────────────────────────────────────────────┘
          │
          ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                      Ruby Application                        │
    │  TagLib::MPEG::File.open('song.mp3') { |f| f.tag.title }     │
    └─────────────────────────────────────────────────────────────┘
```

---

## Key Takeaways

1. **SWIG does the heavy lifting** - Parses C++ headers and generates Ruby C API wrapper code automatically.

2. **Typemaps are critical** - Custom type conversions handle C++ <-> Ruby data marshaling for strings, arrays, and binary data.

3. **Memory management is complex** - Careful tracking prevents segfaults when Ruby GC and C++ destructors interact. Use `%trackobjects`, `%freefunc`, and `DISOWN`.

4. **Module organization** - Each audio format (MPEG, MP4, FLAC) is a separate module with shared base types via `%import`.

5. **Ruby idioms via `%rename`** - Regex-based renaming converts `setFoo()` to `foo=` and `isFoo()` to `foo?` automatically.

6. **`%extend` adds Ruby niceties** - Factory methods, `close()` for deterministic cleanup, `to_h()` for hash conversion.

7. **Pure Ruby layer** - Adds `open() { }` block syntax and other conveniences on top of the C extension.

8. **Cross-platform support** - Works on Linux, macOS, and Windows with appropriate TagLib installation.

---

## References

- [taglib-ruby GitHub](https://github.com/robinst/taglib-ruby)
- [SWIG Documentation](https://www.swig.org/Doc4.1/Ruby.html)
- [TagLib Library](https://taglib.org/)
- [Ruby C API](https://ruby-doc.org/core/doc/extension_rdoc.html)
